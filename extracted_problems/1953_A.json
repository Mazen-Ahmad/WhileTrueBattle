{
  "contestId": 1953,
  "index": "A",
  "name": "Accuracy-Preserving Summation Algorithm",
  "rating": null,
  "tags": [
    "implementation"
  ],
  "statement": "In the classic high-performance computing domain (HPC), the vast majority of computations are conducted in double-precision 64-bit floating-point numbers (fp64, double-precision, IEEE-754 binary64). The rise of Deep Neural Networks (DNNs) resulted in hardware (HW) capable of processing 16-bit floating point numbers (fp16, half precision, IEEE-754 binary16) up to 16 times faster in terms of floating-point operations per second (flops) and up to 4 times faster in terms of memory bandwidth (BW). At the same time, the short mantissa and exponent for fp16 numbers lead to a very fast loss of precision of computations, producing wrong computational results without any option to recover them in reduction operations of size greater than approximately $$$2000$$$. As the typical problem size in HPC is much larger than $$$2000$$$, this makes fp16 computations almost useless. To surmount this major roadblock, smarter algorithms for reduction operations are needed. Description. There is a sequence of floating-point numbers stored in IEEE-754 binary64 (double precision, fp64) format $$$x_i$$$ of length $$$N$$$. The sequence needs to be summed up to $$$S = x_1 + x_2 + \\ldots + x_N$$$. As professional computer equipment with native support for fp16 is usually unavailable to the general audience, we propose to do operations in a simplified simulated environment, that is, we do computations in fp64 format with mantissa and exponent cut to the range admissible in fp16. In particular, small values that do not fit fp16 admissible range turn into zeros, while excessively large values turn into infinities. Objective. Your objective is to sum up as many sequences as possible as fast as possible and as accurately as possible. Please note that you may do summation in fp64 format, but the summation process would be slow though accurate. If you do plain summation in fp16 format, it can be fast, but inaccurate, especially for larger sequences.",
  "inputFormat": "The input consists of a single line. It starts with an integer $$$N$$$ representing the number of values in the sequence. The following $$$N$$$ double precision numbers form the sequence $$$x_i$$$, where $$$i = 1, \\ldots, N$$$. Variable constraints: Length of the sequence: $$$2 \\leq N \\leq 1\\,000\\,000$$$. Value of any individual number in the sequence: legal IEEE-754 binary64 value stored in decimal format. Note that the actual binary64 value is not always exactly equal to the given decimal value. Instead, the actual given value is the closest number representable in binary64. When reading the input, most programming languages will do the conversion for you automatically. It is guaranteed that every number in the sequence either is $$$0$$$ or has absolute value between $$$10^{-300}$$$ and $$$10^{300}$$$, inclusive.",
  "outputFormat": "Print a single line which will describe the summation process. The line should contain an encoded algorithm for the summation. We use this encoding to do actual summation and report the result to prevent the need to seek hardware capable of doing fp16 operations natively. An encoded algorithm consists of the data type to use, followed by a list of values to sum up using this data type. The result of the algorithm is the sum of the given values, as computed in the given data type, from left to right, in the given order. It looks as follows: {type:value_1,value_2,...,value_k} As you can see, the whole algorithm is surrounded by curly brackets (\" { \" and \" } \"). The next character represents one of the three possible data types: \" d \" for fp64 summation, \" s \" for fp32 summation, \" h \" for fp16 summation. Then goes a colon (\" : \"). It is followed by a non-empty list of values to sum up, separated by commas (\" , \"). Note that there are no spaces. Each value can be one of the following: an integer from $$$1$$$ to $$$N$$$ indicating a position in the input sequence: in this case, the value comes directly from the input; another algorithm: in this case, the value is the result of this algorithm. Some examples: {d:1,2,3,4} tells to use double precision to compute $$$x_1 + x_2 + x_3 + x_4$$$; {h:4,3,2,1} tells to use half precision to compute $$$x_4 + x_3 + x_2 + x_1$$$; {d:{s:3,4},{h:2,1}} tells to use double precision to compute $$$y + z$$$, where: $$$y$$$ is to use single precision to compute $$$x_3 + x_4$$$, $$$z$$$ is to use half precision to compute $$$x_2 + x_1$$$; {h:1,4,{d:3,2}} tells to use half precision to compute $$$x_1 + x_4 + y$$$, where: $$$y$$$ is to use double precision to compute $$$x_3 + x_2$$$. Each input value must be used exactly once.",
  "sampleTests": [
    {
      "input": "2 -4.815473e+04 -1.862622e+04",
      "output": "{d:1,2}"
    }
  ],
  "timeLimit": 10000,
  "memoryLimit": 1024,
  "sourceUrl": "https://codeforces.com/problemset/problem/1953/A",
  "verified": true,
  "qualityScore": 4.0,
  "source": "codeforces-scraped"
}