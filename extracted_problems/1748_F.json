{
  "contestId": 1748,
  "index": "F",
  "name": "Circular Xor Reversal",
  "rating": 3000,
  "tags": [
    "implementation"
  ],
  "statement": "You have an array $$$a_0, a_1, \\ldots, a_{n-1}$$$ of length $$$n$$$. Initially, $$$a_i = 2^i$$$ for all $$$0 \\le i \\lt n$$$. Note that array $$$a$$$ is zero-indexed. You want to reverse this array (that is, make $$$a_i$$$ equal to $$$2^{n-1-i}$$$ for all $$$0 \\le i \\lt n$$$). To do this, you can perform the following operation no more than $$$250\\,000$$$ times: Select an integer $$$i$$$ ($$$0 \\le i \\lt n$$$) and replace $$$a_i$$$ by $$$a_i \\oplus a_{(i+1)\\bmod n}$$$. Here, $$$\\oplus$$$ denotes the bitwise XOR operation . Your task is to find any sequence of operations that will result in the array $$$a$$$ being reversed. It can be shown that under the given constraints, a solution always exists.",
  "inputFormat": "The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 400$$$) — the length of the array $$$a$$$.",
  "outputFormat": "On the first line print one integer $$$k$$$ ($$$0 \\le k \\le 250\\,000$$$) — the number of operations performed. On the second line print $$$k$$$ integers $$$i_1,i_2,\\ldots,i_k$$$ ($$$0 \\le i_j \\lt n$$$). Here, $$$i_j$$$ should be the integer selected on the $$$j$$$-th operation. Note that you don't need to minimize the number of operations.",
  "sampleTests": [
    {
      "input": "2",
      "output": "3\n1 0 1"
    }
  ],
  "timeLimit": 2000,
  "memoryLimit": 256,
  "sourceUrl": "https://codeforces.com/problemset/problem/1748/F",
  "verified": true,
  "qualityScore": 4.0,
  "source": "codeforces-scraped"
}