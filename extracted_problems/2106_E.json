{
  "contestId": 2106,
  "index": "E",
  "name": "Wolf",
  "rating": 1800,
  "tags": [
    "implementation"
  ],
  "statement": "Wolf has found $$$n$$$ sheep with tastiness values $$$p_1, p_2, ..., p_n$$$ where $$$p$$$ is a permutation$$$^{\\text{∗}}$$$. Wolf wants to perform binary search on $$$p$$$ to find the sheep with tastiness of $$$k$$$, but $$$p$$$ may not necessarily be sorted. The success of binary search on the range $$$[l, r]$$$ for $$$k$$$ is represented as $$$f(l, r, k)$$$, which is defined as follows: If $$$l > r$$$, then $$$f(l, r, k)$$$ fails. Otherwise, let $$$m = \\lfloor\\frac{l + r}{2}\\rfloor$$$, and: If $$$p_m = k$$$, then $$$f(l, r, k)$$$ is successful , If $$$p_m < k$$$, then $$$f(l, r, k) = f(m+1, r, k)$$$, If $$$p_m > k$$$, then $$$f(l, r, k) = f(l, m-1, k)$$$. Cow the Nerd decides to help Wolf out. Cow the Nerd is given $$$q$$$ queries, each consisting of three integers $$$l$$$, $$$r$$$, and $$$k$$$. Before the search begins, Cow the Nerd may choose a non-negative integer $$$d$$$, and $$$d$$$ indices $$$1 \\le i_1 < i_2 < \\ldots < i_d \\le n$$$ where $$$p_{i_j} \\neq k$$$ over all $$$1 \\leq j \\leq d$$$. Then, he may re-order the elements $$$p_{i_1}, p_{i_2}, ..., p_{i_d}$$$ however he likes. For each query, output the minimum integer $$$d$$$ that Cow the Nerd must choose so that $$$f(l, r, k)$$$ can be successful , or report that it is impossible. Note that the queries are independent and the reordering is not actually performed. $$$^{\\text{∗}}$$$A permutation of length $$$n$$$ is an array that contains every integer from $$$1$$$ to $$$n$$$ exactly once.",
  "inputFormat": "The first line of the input contains a single integer $$$t$$$ $$$(1 \\le t \\le 10^4)$$$ — the number of test cases. The first line of each test contains two integers $$$n$$$ and $$$q$$$ $$$(1 \\le n, q \\le 2 \\cdot 10^5)$$$ — the length of $$$p$$$ and the number of queries respectively. The second line contains $$$n$$$ integers $$$p_1, p_2, ..., p_n$$$ — the tastiness of the $$$i$$$-th sheep. It is guaranteed that every integer from $$$1$$$ to $$$n$$$ appears exactly once in $$$p$$$. The following $$$q$$$ lines contain three integers $$$l$$$, $$$r$$$, and $$$k$$$ $$$(1 \\le l \\le r \\le n, 1 \\le k \\le n)$$$ — the range that the binary search will be performed on and the integer being searched for each query. It is guaranteed that the sum of $$$n$$$ and the sum of $$$q$$$ over all cases do not exceed $$$2 \\cdot 10^5$$$.",
  "outputFormat": "For each query, output the minimum integer $$$d$$$ that Cow the Nerd must choose so that $$$f(l, r, k)$$$ is successful on a new line. If it is impossible, output $$$-1$$$.",
  "sampleTests": [
    {
      "input": "8\n5 3\n1 2 3 4 5\n1 5 4\n1 3 4\n3 4 4\n7 4\n3 1 5 2 7 6 4\n3 4 2\n2 3 5\n1 5 6\n1 7 3\n2 1\n2 1\n1 2 1\n1 1\n1\n1 1 1\n7 1\n3 4 2 5 7 1 6\n1 7 1\n16 1\n16 10 12 6 13 9 14 3 8 11 15 2 7 1 5 4\n1 16 4\n16 1\n14 1 3 15 4 5 6 16 7 8 9 10 11 12 13 2\n1 16 14\n13 1\n12 13 10 9 8 4 11 5 7 6 2 1 3\n1 13 2",
      "output": "0 -1 0 \n2 0 -1 4 \n-1 \n0 \n-1 \n-1 \n-1 \n-1"
    }
  ],
  "timeLimit": 4000,
  "memoryLimit": 256,
  "sourceUrl": "https://codeforces.com/problemset/problem/2106/E",
  "verified": true,
  "qualityScore": 4.0,
  "source": "codeforces-scraped"
}